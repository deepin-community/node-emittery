Description: replace ava by jest
 generated using `npx jest-codemods`
Author: Yadd <yadd@debian.org>
Forwarded: not-needed
Last-Update: 2021-11-16

--- a/test/index.js
+++ b/test/index.js
@@ -1,9 +1,8 @@
-import test from 'ava';
-import delay from 'delay';
-import pEvent from 'p-event';
-import Emittery from '../index.js';
+const delay = require('delay');
+const pEvent = require('p-event');
+const Emittery = require('../index.js');
 
-test('on()', async t => {
+test('on()', async () => {
 	const emitter = new Emittery();
 	const eventName = Symbol('eventName');
 	const calls = [];
@@ -24,10 +23,10 @@
 	emitter.on(eventName, listener3);
 	await emitter.emit('ðŸ¦„');
 	await emitter.emit(eventName);
-	t.deepEqual(calls, [1, 2, 3]);
+	expect(calls).toEqual([1, 2, 3]);
 });
 
-test('on() - multiple event names', async t => {
+test('on() - multiple event names', async () => {
 	const emitter = new Emittery();
 	const eventName = Symbol('eventName');
 	let count = 0;
@@ -39,10 +38,10 @@
 	await emitter.emit('ðŸ¦„');
 	await emitter.emit('ðŸ¶');
 	await emitter.emit(eventName);
-	t.is(count, 3);
+	expect(count).toBe(3);
 });
 
-test('on() - symbol eventName', async t => {
+test('on() - symbol eventName', async () => {
 	const emitter = new Emittery();
 	const eventName = Symbol('eventName');
 	const calls = [];
@@ -57,21 +56,21 @@
 	emitter.on(eventName, listener1);
 	emitter.on(eventName, listener2);
 	await emitter.emit(eventName);
-	t.deepEqual(calls, [1, 2]);
+	expect(calls).toEqual([1, 2]);
 });
 
-test('on() - listenerAdded', async t => {
+test('on() - listenerAdded', async () => {
 	const emitter = new Emittery();
 	const addListener = () => 1;
 	setImmediate(() => emitter.on('abc', addListener));
 	const {eventName, listener} = await pEvent(emitter, Emittery.listenerAdded, {
 		rejectionEvents: []
 	});
-	t.is(listener, addListener);
-	t.is(eventName, 'abc');
+	expect(listener).toBe(addListener);
+	expect(eventName).toBe('abc');
 });
 
-test('on() - listenerRemoved', async t => {
+test('on() - listenerRemoved', async () => {
 	const emitter = new Emittery();
 	const addListener = () => 1;
 	emitter.on('abc', addListener);
@@ -79,30 +78,22 @@
 	const {eventName, listener} = await pEvent(emitter, Emittery.listenerRemoved, {
 		rejectionEvents: []
 	});
-	t.is(listener, addListener);
-	t.is(eventName, 'abc');
+	expect(listener).toBe(addListener);
+	expect(eventName).toBe('abc');
 });
 
-test('on() - listenerAdded onAny', async t => {
+test('on() - listenerAdded onAny', async () => {
 	const emitter = new Emittery();
 	const addListener = () => 1;
 	setImmediate(() => emitter.onAny(addListener));
 	const {eventName, listener} = await pEvent(emitter, Emittery.listenerAdded, {
 		rejectionEvents: []
 	});
-	t.is(listener, addListener);
-	t.is(eventName, undefined);
+	expect(listener).toBe(addListener);
+	expect(eventName).toBe(undefined);
 });
 
-test('off() - listenerAdded', t => {
-	const emitter = new Emittery();
-	const off = emitter.on(Emittery.listenerAdded, () => t.fail());
-	off();
-	emitter.emit('a');
-	t.pass();
-});
-
-test('off() - isDebug logs output', t => {
+test('off() - isDebug logs output', () => {
 	const eventStore = [];
 
 	const emitter = new Emittery({
@@ -117,42 +108,42 @@
 
 	const off = emitter.on('test', () => {});
 	off();
-	t.true(eventStore.length > 0);
-	t.is(eventStore[2].type, 'unsubscribe');
-	t.is(eventStore[2].eventName, 'test');
-	t.is(eventStore[2].debugName, 'testEmitter');
+	expect(eventStore.length > 0).toBe(true);
+	expect(eventStore[2].type).toBe('unsubscribe');
+	expect(eventStore[2].eventName).toBe('test');
+	expect(eventStore[2].debugName).toBe('testEmitter');
 });
 
-test('on() - listenerAdded offAny', async t => {
+test('on() - listenerAdded offAny', async () => {
 	const emitter = new Emittery();
 	const addListener = () => 1;
 	emitter.onAny(addListener);
 	setImmediate(() => emitter.offAny(addListener));
 	const {listener, eventName} = await pEvent(emitter, Emittery.listenerRemoved);
-	t.is(listener, addListener);
-	t.is(eventName, undefined);
+	expect(listener).toBe(addListener);
+	expect(eventName).toBe(undefined);
 });
 
-test('on() - eventName must be a string or a symbol', t => {
+test('on() - eventName must be a string or a symbol', () => {
 	const emitter = new Emittery();
 
 	emitter.on('string', () => {});
 	emitter.on(Symbol('symbol'), () => {});
 
-	t.throws(() => {
+	expect(() => {
 		emitter.on(42, () => {});
-	}, TypeError);
+	}).toThrowError(TypeError);
 });
 
-test('on() - must have a listener', t => {
+test('on() - must have a listener', () => {
 	const emitter = new Emittery();
 
-	t.throws(() => {
+	expect(() => {
 		emitter.on('ðŸ¦„');
-	}, TypeError);
+	}).toThrowError(TypeError);
 });
 
-test('on() - returns a unsubcribe method', async t => {
+test('on() - returns a unsubcribe method', async () => {
 	const emitter = new Emittery();
 	const calls = [];
 	const listener = () => {
@@ -161,14 +152,14 @@
 
 	const off = emitter.on('ðŸ¦„', listener);
 	await emitter.emit('ðŸ¦„');
-	t.deepEqual(calls, [1]);
+	expect(calls).toEqual([1]);
 
 	off();
 	await emitter.emit('ðŸ¦„');
-	t.deepEqual(calls, [1]);
+	expect(calls).toEqual([1]);
 });
 
-test('on() - dedupes identical listeners', async t => {
+test('on() - dedupes identical listeners', async () => {
 	const emitter = new Emittery();
 	const calls = [];
 	const listener = () => {
@@ -179,10 +170,10 @@
 	emitter.on('ðŸ¦„', listener);
 	emitter.on('ðŸ¦„', listener);
 	await emitter.emit('ðŸ¦„');
-	t.deepEqual(calls, [1]);
+	expect(calls).toEqual([1]);
 });
 
-test('on() - isDebug logs output', t => {
+test('on() - isDebug logs output', () => {
 	const eventStore = [];
 	const calls = [];
 
@@ -197,13 +188,13 @@
 	});
 
 	emitter.on('test', data => calls.push(data));
-	t.true(eventStore.length > 0);
-	t.is(eventStore[0].type, 'subscribe');
-	t.is(eventStore[0].debugName, 'testEmitter');
-	t.is(eventStore[0].eventName, 'test');
+	expect(eventStore.length > 0).toBe(true);
+	expect(eventStore[0].type).toBe('subscribe');
+	expect(eventStore[0].debugName).toBe('testEmitter');
+	expect(eventStore[0].eventName).toBe('test');
 });
 
-test.serial('events()', async t => {
+test('events()', async () => {
 	const emitter = new Emittery();
 	const iterator = emitter.events('ðŸ¦„');
 
@@ -212,19 +203,19 @@
 		emitter.emit('ðŸ¦„', Promise.resolve('ðŸŒŸ'));
 	}, 10);
 
-	t.plan(3);
+	expect.assertions(3);
 	const expected = ['ðŸŒˆ', 'ðŸŒŸ'];
 	for await (const data of iterator) {
-		t.deepEqual(data, expected.shift());
+		expect(data).toEqual(expected.shift());
 		if (expected.length === 0) {
 			break;
 		}
 	}
 
-	t.deepEqual(await iterator.next(), {done: true});
+	expect(await iterator.next()).toEqual({done: true});
 });
 
-test.serial('events() - multiple event names', async t => {
+test('events() - multiple event names', async () => {
 	const emitter = new Emittery();
 	const iterator = emitter.events(['ðŸ¦„', 'ðŸ¶']);
 
@@ -234,19 +225,19 @@
 		emitter.emit('ðŸ¦„', Promise.resolve('ðŸŒŸ'));
 	}, 10);
 
-	t.plan(4);
+	expect.assertions(4);
 	const expected = ['ðŸŒˆ', 'ðŸŒˆ', 'ðŸŒŸ'];
 	for await (const data of iterator) {
-		t.deepEqual(data, expected.shift());
+		expect(data).toEqual(expected.shift());
 		if (expected.length === 0) {
 			break;
 		}
 	}
 
-	t.deepEqual(await iterator.next(), {done: true});
+	expect(await iterator.next()).toEqual({done: true});
 });
 
-test('events() - return() called during emit', async t => {
+test('events() - return() called during emit', async () => {
 	const emitter = new Emittery();
 	let iterator = null;
 	emitter.on('ðŸ¦„', () => {
@@ -254,31 +245,31 @@
 	});
 	iterator = emitter.events('ðŸ¦„');
 	emitter.emit('ðŸ¦„', 'ðŸŒˆ');
-	t.deepEqual(await iterator.next(), {done: false, value: 'ðŸŒˆ'});
-	t.deepEqual(await iterator.next(), {done: true});
+	expect(await iterator.next()).toEqual({done: false, value: 'ðŸŒˆ'});
+	expect(await iterator.next()).toEqual({done: true});
 });
 
-test('events() - return() awaits its argument', async t => {
+test('events() - return() awaits its argument', async () => {
 	const emitter = new Emittery();
 	const iterator = emitter.events('ðŸ¦„');
-	t.deepEqual(await iterator.return(Promise.resolve(1)), {done: true, value: 1});
+	expect(await iterator.return(Promise.resolve(1))).toEqual({done: true, value: 1});
 });
 
-test('events() - return() without argument', async t => {
+test('events() - return() without argument', async () => {
 	const emitter = new Emittery();
 	const iterator = emitter.events('ðŸ¦„');
-	t.deepEqual(await iterator.return(), {done: true});
+	expect(await iterator.return()).toEqual({done: true});
 });
 
-test('events() - discarded iterators should stop receiving events', async t => {
+test('events() - discarded iterators should stop receiving events', async () => {
 	const emitter = new Emittery();
 	const iterator = emitter.events('ðŸ¦„');
 
 	await emitter.emit('ðŸ¦„', 'ðŸŒˆ');
-	t.deepEqual(await iterator.next(), {value: 'ðŸŒˆ', done: false});
+	expect(await iterator.next()).toEqual({value: 'ðŸŒˆ', done: false});
 	await iterator.return();
 	await emitter.emit('ðŸ¦„', 'ðŸŒˆ');
-	t.deepEqual(await iterator.next(), {done: true});
+	expect(await iterator.next()).toEqual({done: true});
 
 	setTimeout(() => {
 		emitter.emit('ðŸ¦„', 'ðŸŒŸ');
@@ -288,10 +279,10 @@
 		setTimeout(resolve, 20);
 	});
 
-	t.deepEqual(await iterator.next(), {done: true});
+	expect(await iterator.next()).toEqual({done: true});
 });
 
-test('off()', async t => {
+test('off()', async () => {
 	const emitter = new Emittery();
 	const calls = [];
 	const listener = () => {
@@ -300,14 +291,14 @@
 
 	emitter.on('ðŸ¦„', listener);
 	await emitter.emit('ðŸ¦„');
-	t.deepEqual(calls, [1]);
+	expect(calls).toEqual([1]);
 
 	emitter.off('ðŸ¦„', listener);
 	await emitter.emit('ðŸ¦„');
-	t.deepEqual(calls, [1]);
+	expect(calls).toEqual([1]);
 });
 
-test('off() - multiple event names', async t => {
+test('off() - multiple event names', async () => {
 	const emitter = new Emittery();
 	const calls = [];
 	const listener = () => {
@@ -316,77 +307,68 @@
 
 	emitter.on(['ðŸ¦„', 'ðŸ¶', 'ðŸ¦Š'], listener);
 	await emitter.emit('ðŸ¦„');
-	t.deepEqual(calls, [1]);
+	expect(calls).toEqual([1]);
 
 	emitter.off(['ðŸ¦„', 'ðŸ¶'], listener);
 	await emitter.emit('ðŸ¦„');
 	await emitter.emit('ðŸ¶');
-	t.deepEqual(calls, [1]);
+	expect(calls).toEqual([1]);
 
 	await emitter.emit('ðŸ¦Š');
-	t.deepEqual(calls, [1, 1]);
+	expect(calls).toEqual([1, 1]);
 });
 
-test('off() - eventName must be a string or a symbol', t => {
+test('off() - eventName must be a string or a symbol', () => {
 	const emitter = new Emittery();
 
 	emitter.on('string', () => {});
 	emitter.on(Symbol('symbol'), () => {});
 
-	t.throws(() => {
+	expect(() => {
 		emitter.off(42);
-	}, TypeError);
+	}).toThrowError(TypeError);
 });
 
-test('off() - no listener', t => {
+test('off() - no listener', () => {
 	const emitter = new Emittery();
 
-	t.throws(() => {
+	expect(() => {
 		emitter.off('ðŸ¦„');
-	}, TypeError);
+	}).toThrowError(TypeError);
 });
 
-test('once()', async t => {
+test('once()', async () => {
 	const fixture = 'ðŸŒˆ';
 	const emitter = new Emittery();
 	const promise = emitter.once('ðŸ¦„');
 	emitter.emit('ðŸ¦„', fixture);
-	t.is(await promise, fixture);
+	expect(await promise).toBe(fixture);
 });
 
-test('once() - multiple event names', async t => {
+test('once() - multiple event names', async () => {
 	const fixture = 'ðŸŒˆ';
 	const emitter = new Emittery();
 	const promise = emitter.once(['ðŸ¦„', 'ðŸ¶']);
 	emitter.emit('ðŸ¶', fixture);
-	t.is(await promise, fixture);
-});
-
-test('once() - eventName must be a string or a symbol', async t => {
-	const emitter = new Emittery();
-
-	emitter.once('string');
-	emitter.once(Symbol('symbol'));
-
-	await t.throwsAsync(emitter.once(42), TypeError);
+	expect(await promise).toBe(fixture);
 });
 
-test.cb('emit() - one event', t => {
-	t.plan(1);
+test('emit() - one event', done => {
+	expect.assertions(1);
 
 	const emitter = new Emittery();
 	const eventFixture = {foo: true};
 
 	emitter.on('ðŸ¦„', data => {
-		t.deepEqual(data, eventFixture);
-		t.end();
+		expect(data).toEqual(eventFixture);
+		done();
 	});
 
 	emitter.emit('ðŸ¦„', eventFixture);
 });
 
-test.cb('emit() - multiple events', t => {
-	t.plan(1);
+test('emit() - multiple events', done => {
+	expect.assertions(1);
 
 	const emitter = new Emittery();
 	let count = 0;
@@ -395,8 +377,8 @@
 		await delay(Math.random() * 100);
 
 		if (++count >= 5) {
-			t.is(count, 5);
-			t.end();
+			expect(count).toBe(5);
+			done();
 		}
 	});
 
@@ -407,33 +389,23 @@
 	emitter.emit('ðŸ¦„');
 });
 
-test('emit() - eventName must be a string or a symbol', async t => {
-	const emitter = new Emittery();
-
-	emitter.emit('string');
-	emitter.emit(Symbol('symbol'));
-
-	await t.throwsAsync(emitter.emit(42), TypeError);
-});
-
-test.cb('emit() - is async', t => {
-	t.plan(2);
+test('emit() - is async', done => {
+	expect.assertions(1);
 
 	const emitter = new Emittery();
 	let unicorn = false;
 
 	emitter.on('ðŸ¦„', () => {
-		unicorn = true;
-		t.pass();
-		t.end();
-	});
+        unicorn = true;
+        done();
+    });
 
 	emitter.emit('ðŸ¦„');
 
-	t.false(unicorn);
+	expect(unicorn).toBe(false);
 });
 
-test('emit() - awaits async listeners', async t => {
+test('emit() - awaits async listeners', async () => {
 	const emitter = new Emittery();
 	let unicorn = false;
 
@@ -443,12 +415,12 @@
 	});
 
 	const promise = emitter.emit('ðŸ¦„');
-	t.false(unicorn);
+	expect(unicorn).toBe(false);
 	await promise;
-	t.true(unicorn);
+	expect(unicorn).toBe(true);
 });
 
-test('emit() - calls listeners subscribed when emit() was invoked', async t => {
+test('emit() - calls listeners subscribed when emit() was invoked', async () => {
 	const emitter = new Emittery();
 	const calls = [];
 	const off1 = emitter.on('ðŸ¦„', () => {
@@ -459,7 +431,7 @@
 		calls.push(2);
 	});
 	await p;
-	t.deepEqual(calls, [1]);
+	expect(calls).toEqual([1]);
 
 	const off3 = emitter.on('ðŸ¦„', () => {
 		calls.push(3);
@@ -469,7 +441,7 @@
 		});
 	});
 	await emitter.emit('ðŸ¦„');
-	t.deepEqual(calls, [1, 1, 2, 3]);
+	expect(calls).toEqual([1, 1, 2, 3]);
 	off3();
 
 	const off5 = emitter.on('ðŸ¦„', () => {
@@ -479,7 +451,7 @@
 		});
 	});
 	await emitter.emit('ðŸ¦„');
-	t.deepEqual(calls, [1, 1, 2, 3, 2, 4, 5]);
+	expect(calls).toEqual([1, 1, 2, 3, 2, 4, 5]);
 	off5();
 
 	let off8 = null;
@@ -491,7 +463,7 @@
 		calls.push(8);
 	});
 	await emitter.emit('ðŸ¦„');
-	t.deepEqual(calls, [1, 1, 2, 3, 2, 4, 5, 2, 4, 7, 6]);
+	expect(calls).toEqual([1, 1, 2, 3, 2, 4, 5, 2, 4, 7, 6]);
 
 	let off10 = null;
 	emitter.onAny(() => {
@@ -502,18 +474,18 @@
 		calls.push(10);
 	});
 	await emitter.emit('ðŸ¦„');
-	t.deepEqual(calls, [1, 1, 2, 3, 2, 4, 5, 2, 4, 7, 6, 2, 4, 7, 6, 9]);
+	expect(calls).toEqual([1, 1, 2, 3, 2, 4, 5, 2, 4, 7, 6, 2, 4, 7, 6, 9]);
 
 	await emitter.emit('ðŸ¦„');
-	t.deepEqual(calls, [1, 1, 2, 3, 2, 4, 5, 2, 4, 7, 6, 2, 4, 7, 6, 9, 2, 4, 7, 6, 9]);
+	expect(calls).toEqual([1, 1, 2, 3, 2, 4, 5, 2, 4, 7, 6, 2, 4, 7, 6, 9, 2, 4, 7, 6, 9]);
 
 	const p2 = emitter.emit('ðŸ¦„');
 	emitter.clearListeners();
 	await p2;
-	t.deepEqual(calls, [1, 1, 2, 3, 2, 4, 5, 2, 4, 7, 6, 2, 4, 7, 6, 9, 2, 4, 7, 6, 9]);
+	expect(calls).toEqual([1, 1, 2, 3, 2, 4, 5, 2, 4, 7, 6, 2, 4, 7, 6, 9, 2, 4, 7, 6, 9]);
 });
 
-test('emit() - isDebug logs output', async t => {
+test('emit() - isDebug logs output', async () => {
 	const eventStore = [];
 
 	const emitter = new Emittery({
@@ -528,39 +500,25 @@
 
 	emitter.on('test', () => {});
 	await emitter.emit('test', 'data');
-	t.true(eventStore.length > 0);
-	t.is(eventStore[2].type, 'emit');
-	t.is(eventStore[2].eventName, 'test');
-	t.is(eventStore[2].debugName, 'testEmitter');
-	t.is(eventStore[2].eventData, 'data');
+	expect(eventStore.length > 0).toBe(true);
+	expect(eventStore[2].type).toBe('emit');
+	expect(eventStore[2].eventName).toBe('test');
+	expect(eventStore[2].debugName).toBe('testEmitter');
+	expect(eventStore[2].eventData).toBe('data');
 });
 
-test('emit() - returns undefined', async t => {
+test('emit() - returns undefined', async () => {
 	const emitter = new Emittery();
 
 	emitter.on('ðŸ¦„', () => 'ðŸŒˆ');
-	t.is(await emitter.emit('ðŸ¦„'), undefined);
+	expect(await emitter.emit('ðŸ¦„')).toBe(undefined);
 
 	emitter.on('ðŸ¦„ðŸ¦„', async () => 'ðŸŒˆ');
-	t.is(await emitter.emit('ðŸ¦„ðŸ¦„'), undefined);
+	expect(await emitter.emit('ðŸ¦„ðŸ¦„')).toBe(undefined);
 });
 
-test('emit() - throws an error if any listener throws', async t => {
-	const emitter = new Emittery();
-
-	emitter.on('ðŸ¦„', () => {
-		throw new Error('ðŸŒˆ');
-	});
-	await t.throwsAsync(emitter.emit('ðŸ¦„'), {instanceOf: Error});
-
-	emitter.on('ðŸ¦„ðŸ¦„', async () => {
-		throw new Error('ðŸŒˆ');
-	});
-	await t.throwsAsync(emitter.emit('ðŸ¦„ðŸ¦„'), {instanceOf: Error});
-});
-
-test.cb('emitSerial()', t => {
-	t.plan(1);
+test('emitSerial()', done => {
+	expect.assertions(1);
 
 	const emitter = new Emittery();
 	const events = [];
@@ -570,8 +528,8 @@
 		events.push(data);
 
 		if (events.length >= 5) {
-			t.deepEqual(events, [1, 2, 3, 4, 5]);
-			t.end();
+			expect(events).toEqual([1, 2, 3, 4, 5]);
+			done();
 		}
 	};
 
@@ -584,33 +542,23 @@
 	emitter.emitSerial('ðŸ¦„', 'e');
 });
 
-test('emitSerial() - eventName must be a string or a symbol', async t => {
-	const emitter = new Emittery();
-
-	emitter.emitSerial('string');
-	emitter.emitSerial(Symbol('symbol'));
-
-	await t.throwsAsync(emitter.emitSerial(42), TypeError);
-});
-
-test.cb('emitSerial() - is async', t => {
-	t.plan(2);
+test('emitSerial() - is async', done => {
+	expect.assertions(1);
 
 	const emitter = new Emittery();
 	let unicorn = false;
 
 	emitter.on('ðŸ¦„', () => {
-		unicorn = true;
-		t.pass();
-		t.end();
-	});
+        unicorn = true;
+        done();
+    });
 
 	emitter.emitSerial('ðŸ¦„');
 
-	t.false(unicorn);
+	expect(unicorn).toBe(false);
 });
 
-test('emitSerial() - calls listeners subscribed when emitSerial() was invoked', async t => {
+test('emitSerial() - calls listeners subscribed when emitSerial() was invoked', async () => {
 	const emitter = new Emittery();
 	const calls = [];
 	const off1 = emitter.on('ðŸ¦„', () => {
@@ -621,7 +569,7 @@
 		calls.push(2);
 	});
 	await p;
-	t.deepEqual(calls, [1]);
+	expect(calls).toEqual([1]);
 
 	const off3 = emitter.on('ðŸ¦„', () => {
 		calls.push(3);
@@ -631,7 +579,7 @@
 		});
 	});
 	await emitter.emitSerial('ðŸ¦„');
-	t.deepEqual(calls, [1, 1, 2, 3]);
+	expect(calls).toEqual([1, 1, 2, 3]);
 	off3();
 
 	const off5 = emitter.on('ðŸ¦„', () => {
@@ -641,7 +589,7 @@
 		});
 	});
 	await emitter.emitSerial('ðŸ¦„');
-	t.deepEqual(calls, [1, 1, 2, 3, 2, 4, 5]);
+	expect(calls).toEqual([1, 1, 2, 3, 2, 4, 5]);
 	off5();
 
 	let off8 = null;
@@ -653,7 +601,7 @@
 		calls.push(8);
 	});
 	await emitter.emitSerial('ðŸ¦„');
-	t.deepEqual(calls, [1, 1, 2, 3, 2, 4, 5, 2, 4, 7, 6]);
+	expect(calls).toEqual([1, 1, 2, 3, 2, 4, 5, 2, 4, 7, 6]);
 
 	let off10 = null;
 	emitter.onAny(() => {
@@ -664,18 +612,18 @@
 		calls.push(10);
 	});
 	await emitter.emitSerial('ðŸ¦„');
-	t.deepEqual(calls, [1, 1, 2, 3, 2, 4, 5, 2, 4, 7, 6, 2, 4, 7, 6, 9]);
+	expect(calls).toEqual([1, 1, 2, 3, 2, 4, 5, 2, 4, 7, 6, 2, 4, 7, 6, 9]);
 
 	await emitter.emitSerial('ðŸ¦„');
-	t.deepEqual(calls, [1, 1, 2, 3, 2, 4, 5, 2, 4, 7, 6, 2, 4, 7, 6, 9, 2, 4, 7, 6, 9]);
+	expect(calls).toEqual([1, 1, 2, 3, 2, 4, 5, 2, 4, 7, 6, 2, 4, 7, 6, 9, 2, 4, 7, 6, 9]);
 
 	const p2 = emitter.emitSerial('ðŸ¦„');
 	emitter.clearListeners();
 	await p2;
-	t.deepEqual(calls, [1, 1, 2, 3, 2, 4, 5, 2, 4, 7, 6, 2, 4, 7, 6, 9, 2, 4, 7, 6, 9]);
+	expect(calls).toEqual([1, 1, 2, 3, 2, 4, 5, 2, 4, 7, 6, 2, 4, 7, 6, 9, 2, 4, 7, 6, 9]);
 });
 
-test('emitSerial() - isDebug logs output', async t => {
+test('emitSerial() - isDebug logs output', async () => {
 	const eventStore = [];
 
 	const emitter = new Emittery({
@@ -690,37 +638,37 @@
 
 	emitter.on('test', () => {});
 	await emitter.emitSerial('test', 'data');
-	t.true(eventStore.length > 0);
-	t.is(eventStore[2].type, 'emitSerial');
-	t.is(eventStore[2].eventName, 'test');
-	t.is(eventStore[2].debugName, 'testEmitter');
-	t.is(eventStore[2].eventData, 'data');
+	expect(eventStore.length > 0).toBe(true);
+	expect(eventStore[2].type).toBe('emitSerial');
+	expect(eventStore[2].eventName).toBe('test');
+	expect(eventStore[2].debugName).toBe('testEmitter');
+	expect(eventStore[2].eventData).toBe('data');
 });
 
-test('onAny()', async t => {
-	t.plan(4);
+test('onAny()', async () => {
+	expect.assertions(4);
 
 	const emitter = new Emittery();
 	const eventFixture = {foo: true};
 
 	emitter.onAny((eventName, data) => {
-		t.is(eventName, 'ðŸ¦„');
-		t.deepEqual(data, eventFixture);
+		expect(eventName).toBe('ðŸ¦„');
+		expect(data).toEqual(eventFixture);
 	});
 
 	await emitter.emit('ðŸ¦„', eventFixture);
 	await emitter.emitSerial('ðŸ¦„', eventFixture);
 });
 
-test('onAny() - must have a listener', t => {
+test('onAny() - must have a listener', () => {
 	const emitter = new Emittery();
 
-	t.throws(() => {
+	expect(() => {
 		emitter.onAny();
-	}, TypeError);
+	}).toThrowError(TypeError);
 });
 
-test.serial('anyEvent()', async t => {
+test('anyEvent()', async () => {
 	const emitter = new Emittery();
 	const iterator = emitter.anyEvent();
 
@@ -729,19 +677,19 @@
 		emitter.emit('ðŸ¦„', Promise.resolve('ðŸŒŸ'));
 	}, 10);
 
-	t.plan(3);
+	expect.assertions(3);
 	const expected = [['ðŸ¦„', 'ðŸŒˆ'], ['ðŸ¦„', 'ðŸŒŸ']];
 	for await (const data of iterator) {
-		t.deepEqual(data, expected.shift());
+		expect(data).toEqual(expected.shift());
 		if (expected.length === 0) {
 			break;
 		}
 	}
 
-	t.deepEqual(await iterator.next(), {done: true});
+	expect(await iterator.next()).toEqual({done: true});
 });
 
-test('anyEvent() - return() called during emit', async t => {
+test('anyEvent() - return() called during emit', async () => {
 	const emitter = new Emittery();
 	let iterator = null;
 	emitter.onAny(() => {
@@ -749,19 +697,19 @@
 	});
 	iterator = emitter.anyEvent();
 	emitter.emit('ðŸ¦„', 'ðŸŒˆ');
-	t.deepEqual(await iterator.next(), {done: false, value: ['ðŸ¦„', 'ðŸŒˆ']});
-	t.deepEqual(await iterator.next(), {done: true});
+	expect(await iterator.next()).toEqual({done: false, value: ['ðŸ¦„', 'ðŸŒˆ']});
+	expect(await iterator.next()).toEqual({done: true});
 });
 
-test('anyEvents() - discarded iterators should stop receiving events', async t => {
+test('anyEvents() - discarded iterators should stop receiving events', async () => {
 	const emitter = new Emittery();
 	const iterator = emitter.anyEvent();
 
 	await emitter.emit('ðŸ¦„', 'ðŸŒˆ');
-	t.deepEqual(await iterator.next(), {value: ['ðŸ¦„', 'ðŸŒˆ'], done: false});
+	expect(await iterator.next()).toEqual({value: ['ðŸ¦„', 'ðŸŒˆ'], done: false});
 	await iterator.return();
 	await emitter.emit('ðŸ¦„', 'ðŸŒˆ');
-	t.deepEqual(await iterator.next(), {done: true});
+	expect(await iterator.next()).toEqual({done: true});
 
 	setTimeout(() => {
 		emitter.emit('ðŸ¦„', 'ðŸŒŸ');
@@ -771,10 +719,10 @@
 		setTimeout(resolve, 20);
 	});
 
-	t.deepEqual(await iterator.next(), {done: true});
+	expect(await iterator.next()).toEqual({done: true});
 });
 
-test('offAny()', async t => {
+test('offAny()', async () => {
 	const emitter = new Emittery();
 	const calls = [];
 	const listener = () => {
@@ -783,21 +731,21 @@
 
 	emitter.onAny(listener);
 	await emitter.emit('ðŸ¦„');
-	t.deepEqual(calls, [1]);
+	expect(calls).toEqual([1]);
 	emitter.offAny(listener);
 	await emitter.emit('ðŸ¦„');
-	t.deepEqual(calls, [1]);
+	expect(calls).toEqual([1]);
 });
 
-test('offAny() - no listener', t => {
+test('offAny() - no listener', () => {
 	const emitter = new Emittery();
 
-	t.throws(() => {
+	expect(() => {
 		emitter.offAny();
-	}, TypeError);
+	}).toThrowError(TypeError);
 });
 
-test('clearListeners()', async t => {
+test('clearListeners()', async () => {
 	const emitter = new Emittery();
 	const calls = [];
 	emitter.on('ðŸ¦„', () => {
@@ -817,32 +765,32 @@
 	});
 	await emitter.emit('ðŸ¦„');
 	await emitter.emit('ðŸŒˆ');
-	t.deepEqual(calls, ['ðŸ¦„1', 'ðŸ¦„2', 'any1', 'any2', 'ðŸŒˆ', 'any1', 'any2']);
+	expect(calls).toEqual(['ðŸ¦„1', 'ðŸ¦„2', 'any1', 'any2', 'ðŸŒˆ', 'any1', 'any2']);
 	emitter.clearListeners();
 	await emitter.emit('ðŸ¦„');
 	await emitter.emit('ðŸŒˆ');
-	t.deepEqual(calls, ['ðŸ¦„1', 'ðŸ¦„2', 'any1', 'any2', 'ðŸŒˆ', 'any1', 'any2']);
+	expect(calls).toEqual(['ðŸ¦„1', 'ðŸ¦„2', 'any1', 'any2', 'ðŸŒˆ', 'any1', 'any2']);
 });
 
-test('clearListeners() - also clears iterators', async t => {
+test('clearListeners() - also clears iterators', async () => {
 	const emitter = new Emittery();
 	const iterator = emitter.events('ðŸ¦„');
 	const anyIterator = emitter.anyEvent();
 	await emitter.emit('ðŸ¦„', 'ðŸŒŸ');
 	await emitter.emit('ðŸŒˆ', 'ðŸŒŸ');
-	t.deepEqual(await iterator.next(), {done: false, value: 'ðŸŒŸ'});
-	t.deepEqual(await anyIterator.next(), {done: false, value: ['ðŸ¦„', 'ðŸŒŸ']});
-	t.deepEqual(await anyIterator.next(), {done: false, value: ['ðŸŒˆ', 'ðŸŒŸ']});
+	expect(await iterator.next()).toEqual({done: false, value: 'ðŸŒŸ'});
+	expect(await anyIterator.next()).toEqual({done: false, value: ['ðŸ¦„', 'ðŸŒŸ']});
+	expect(await anyIterator.next()).toEqual({done: false, value: ['ðŸŒˆ', 'ðŸŒŸ']});
 	await emitter.emit('ðŸ¦„', 'ðŸ’«');
 	emitter.clearListeners();
 	await emitter.emit('ðŸŒˆ', 'ðŸ’«');
-	t.deepEqual(await iterator.next(), {done: false, value: 'ðŸ’«'});
-	t.deepEqual(await iterator.next(), {done: true});
-	t.deepEqual(await anyIterator.next(), {done: false, value: ['ðŸ¦„', 'ðŸ’«']});
-	t.deepEqual(await anyIterator.next(), {done: true});
+	expect(await iterator.next()).toEqual({done: false, value: 'ðŸ’«'});
+	expect(await iterator.next()).toEqual({done: true});
+	expect(await anyIterator.next()).toEqual({done: false, value: ['ðŸ¦„', 'ðŸ’«']});
+	expect(await anyIterator.next()).toEqual({done: true});
 });
 
-test('clearListeners() - with event name', async t => {
+test('clearListeners() - with event name', async () => {
 	const emitter = new Emittery();
 	const calls = [];
 	emitter.on('ðŸ¦„', () => {
@@ -862,14 +810,16 @@
 	});
 	await emitter.emit('ðŸ¦„');
 	await emitter.emit('ðŸŒˆ');
-	t.deepEqual(calls, ['ðŸ¦„1', 'ðŸ¦„2', 'any1', 'any2', 'ðŸŒˆ', 'any1', 'any2']);
+	expect(calls).toEqual(['ðŸ¦„1', 'ðŸ¦„2', 'any1', 'any2', 'ðŸŒˆ', 'any1', 'any2']);
 	emitter.clearListeners('ðŸ¦„');
 	await emitter.emit('ðŸ¦„');
 	await emitter.emit('ðŸŒˆ');
-	t.deepEqual(calls, ['ðŸ¦„1', 'ðŸ¦„2', 'any1', 'any2', 'ðŸŒˆ', 'any1', 'any2', 'any1', 'any2', 'ðŸŒˆ', 'any1', 'any2']);
+	expect(calls).toEqual(
+        ['ðŸ¦„1', 'ðŸ¦„2', 'any1', 'any2', 'ðŸŒˆ', 'any1', 'any2', 'any1', 'any2', 'ðŸŒˆ', 'any1', 'any2']
+    );
 });
 
-test('clearListeners() - with multiple event names', async t => {
+test('clearListeners() - with multiple event names', async () => {
 	const emitter = new Emittery();
 	const calls = [];
 	emitter.on('ðŸ¦„', () => {
@@ -886,32 +836,32 @@
 	});
 	await emitter.emit('ðŸ¦„');
 	await emitter.emit('ðŸŒˆ');
-	t.deepEqual(calls, ['ðŸ¦„1', 'ðŸ¦„2', 'any1', 'ðŸŒˆ', 'any1']);
+	expect(calls).toEqual(['ðŸ¦„1', 'ðŸ¦„2', 'any1', 'ðŸŒˆ', 'any1']);
 	emitter.clearListeners(['ðŸ¦„', 'ðŸŒˆ']);
 	await emitter.emit('ðŸ¦„');
 	await emitter.emit('ðŸŒˆ');
-	t.deepEqual(calls, ['ðŸ¦„1', 'ðŸ¦„2', 'any1', 'ðŸŒˆ', 'any1', 'any1', 'any1']);
+	expect(calls).toEqual(['ðŸ¦„1', 'ðŸ¦„2', 'any1', 'ðŸŒˆ', 'any1', 'any1', 'any1']);
 });
 
-test('clearListeners() - with event name - clears iterators for that event', async t => {
+test('clearListeners() - with event name - clears iterators for that event', async () => {
 	const emitter = new Emittery();
 	const iterator = emitter.events('ðŸ¦„');
 	const anyIterator = emitter.anyEvent();
 	await emitter.emit('ðŸ¦„', 'ðŸŒŸ');
 	await emitter.emit('ðŸŒˆ', 'ðŸŒŸ');
-	t.deepEqual(await iterator.next(), {done: false, value: 'ðŸŒŸ'});
-	t.deepEqual(await anyIterator.next(), {done: false, value: ['ðŸ¦„', 'ðŸŒŸ']});
-	t.deepEqual(await anyIterator.next(), {done: false, value: ['ðŸŒˆ', 'ðŸŒŸ']});
+	expect(await iterator.next()).toEqual({done: false, value: 'ðŸŒŸ'});
+	expect(await anyIterator.next()).toEqual({done: false, value: ['ðŸ¦„', 'ðŸŒŸ']});
+	expect(await anyIterator.next()).toEqual({done: false, value: ['ðŸŒˆ', 'ðŸŒŸ']});
 	await emitter.emit('ðŸ¦„', 'ðŸ’«');
 	emitter.clearListeners('ðŸ¦„');
 	await emitter.emit('ðŸŒˆ', 'ðŸ’«');
-	t.deepEqual(await iterator.next(), {done: false, value: 'ðŸ’«'});
-	t.deepEqual(await iterator.next(), {done: true});
-	t.deepEqual(await anyIterator.next(), {done: false, value: ['ðŸ¦„', 'ðŸ’«']});
-	t.deepEqual(await anyIterator.next(), {done: false, value: ['ðŸŒˆ', 'ðŸ’«']});
+	expect(await iterator.next()).toEqual({done: false, value: 'ðŸ’«'});
+	expect(await iterator.next()).toEqual({done: true});
+	expect(await anyIterator.next()).toEqual({done: false, value: ['ðŸ¦„', 'ðŸ’«']});
+	expect(await anyIterator.next()).toEqual({done: false, value: ['ðŸŒˆ', 'ðŸ’«']});
 });
 
-test('clearListeners() - isDebug logs output', t => {
+test('clearListeners() - isDebug logs output', () => {
 	const eventStore = [];
 
 	const emitter = new Emittery({
@@ -926,13 +876,13 @@
 
 	emitter.on('test', () => {});
 	emitter.clearListeners('test');
-	t.true(eventStore.length > 0);
-	t.is(eventStore[2].type, 'clear');
-	t.is(eventStore[2].eventName, 'test');
-	t.is(eventStore[2].debugName, 'testEmitter');
+	expect(eventStore.length > 0).toBe(true);
+	expect(eventStore[2].type).toBe('clear');
+	expect(eventStore[2].eventName).toBe('test');
+	expect(eventStore[2].debugName).toBe('testEmitter');
 });
 
-test('onAny() - isDebug logs output', t => {
+test('onAny() - isDebug logs output', () => {
 	const eventStore = [];
 
 	const emitter = new Emittery({
@@ -946,13 +896,13 @@
 	});
 
 	emitter.onAny(() => {});
-	t.true(eventStore.length > 0);
-	t.is(eventStore[0].type, 'subscribeAny');
-	t.is(eventStore[0].eventName, undefined);
-	t.is(eventStore[0].debugName, 'testEmitter');
+	expect(eventStore.length > 0).toBe(true);
+	expect(eventStore[0].type).toBe('subscribeAny');
+	expect(eventStore[0].eventName).toBe(undefined);
+	expect(eventStore[0].debugName).toBe('testEmitter');
 });
 
-test('offAny() - isDebug logs output', t => {
+test('offAny() - isDebug logs output', () => {
 	const eventStore = [];
 
 	const emitter = new Emittery({
@@ -967,54 +917,54 @@
 
 	const off = emitter.onAny(() => {});
 	off();
-	t.true(eventStore.length > 0);
-	t.is(eventStore[2].type, 'unsubscribeAny');
-	t.is(eventStore[2].eventName, undefined);
-	t.is(eventStore[2].debugName, 'testEmitter');
+	expect(eventStore.length > 0).toBe(true);
+	expect(eventStore[2].type).toBe('unsubscribeAny');
+	expect(eventStore[2].eventName).toBe(undefined);
+	expect(eventStore[2].debugName).toBe('testEmitter');
 });
 
-test('listenerCount()', t => {
+test('listenerCount()', () => {
 	const emitter = new Emittery();
 	emitter.on('ðŸ¦„', () => {});
 	emitter.on('ðŸŒˆ', () => {});
 	emitter.on('ðŸ¦„', () => {});
 	emitter.onAny(() => {});
 	emitter.onAny(() => {});
-	t.is(emitter.listenerCount('ðŸ¦„'), 4);
-	t.is(emitter.listenerCount('ðŸŒˆ'), 3);
-	t.is(emitter.listenerCount(), 5);
+	expect(emitter.listenerCount('ðŸ¦„')).toBe(4);
+	expect(emitter.listenerCount('ðŸŒˆ')).toBe(3);
+	expect(emitter.listenerCount()).toBe(5);
 });
 
-test('listenerCount() - multiple event names', t => {
+test('listenerCount() - multiple event names', () => {
 	const emitter = new Emittery();
 	emitter.on('ðŸ¦„', () => {});
 	emitter.on('ðŸŒˆ', () => {});
 	emitter.on('ðŸ¦„', () => {});
 	emitter.onAny(() => {});
 	emitter.onAny(() => {});
-	t.is(emitter.listenerCount(['ðŸ¦„', 'ðŸŒˆ']), 7);
-	t.is(emitter.listenerCount(), 5);
+	expect(emitter.listenerCount(['ðŸ¦„', 'ðŸŒˆ'])).toBe(7);
+	expect(emitter.listenerCount()).toBe(5);
 });
 
-test('listenerCount() - works with empty eventName strings', t => {
+test('listenerCount() - works with empty eventName strings', () => {
 	const emitter = new Emittery();
 	emitter.on('', () => {});
-	t.is(emitter.listenerCount(''), 1);
+	expect(emitter.listenerCount('')).toBe(1);
 });
 
-test('listenerCount() - eventName must be undefined if not a string nor a symbol', t => {
+test('listenerCount() - eventName must be undefined if not a string nor a symbol', () => {
 	const emitter = new Emittery();
 
 	emitter.listenerCount('string');
 	emitter.listenerCount(Symbol('symbol'));
 	emitter.listenerCount();
 
-	t.throws(() => {
+	expect(() => {
 		emitter.listenerCount(42);
-	}, TypeError);
+	}).toThrowError(TypeError);
 });
 
-test('bindMethods()', t => {
+test('bindMethods()', () => {
 	const methodsToBind = ['on', 'off', 'emit', 'listenerCount'];
 
 	const emitter = new Emittery();
@@ -1023,42 +973,42 @@
 	const oldPropertyNames = Object.getOwnPropertyNames(target);
 	emitter.bindMethods(target, methodsToBind);
 
-	t.deepEqual(Object.getOwnPropertyNames(target).sort(), [...oldPropertyNames, ...methodsToBind].sort());
+	expect(Object.getOwnPropertyNames(target).sort()).toEqual([...oldPropertyNames, ...methodsToBind].sort());
 
 	for (const method of methodsToBind) {
-		t.is(typeof target[method], 'function');
+		expect(typeof target[method]).toBe('function');
 	}
 
-	t.is(target.listenerCount(), 0);
+	expect(target.listenerCount()).toBe(0);
 });
 
-test('bindMethods() - methodNames must be array of strings or undefined', t => {
-	t.throws(() => {
+test('bindMethods() - methodNames must be array of strings or undefined', () => {
+	expect(() => {
 		new Emittery().bindMethods({}, null);
-	});
+	}).toThrow();
 
-	t.throws(() => {
+	expect(() => {
 		new Emittery().bindMethods({}, 'string');
-	});
+	}).toThrow();
 
-	t.throws(() => {
+	expect(() => {
 		new Emittery().bindMethods({}, {});
-	});
+	}).toThrow();
 
-	t.throws(() => {
+	expect(() => {
 		new Emittery().bindMethods({}, [null]);
-	});
+	}).toThrow();
 
-	t.throws(() => {
+	expect(() => {
 		new Emittery().bindMethods({}, [1]);
-	});
+	}).toThrow();
 
-	t.throws(() => {
+	expect(() => {
 		new Emittery().bindMethods({}, [{}]);
-	});
+	}).toThrow();
 });
 
-test('bindMethods() - must bind all methods if no array supplied', t => {
+test('bindMethods() - must bind all methods if no array supplied', () => {
 	const methodsExpected = ['on', 'off', 'once', 'events', 'emit', 'emitSerial', 'onAny', 'anyEvent', 'offAny', 'clearListeners', 'listenerCount', 'bindMethods', 'logIfDebugEnabled'];
 
 	const emitter = new Emittery();
@@ -1067,37 +1017,37 @@
 	const oldPropertyNames = Object.getOwnPropertyNames(target);
 	emitter.bindMethods(target);
 
-	t.deepEqual(Object.getOwnPropertyNames(target).sort(), [...oldPropertyNames, ...methodsExpected].sort());
+	expect(Object.getOwnPropertyNames(target).sort()).toEqual([...oldPropertyNames, ...methodsExpected].sort());
 
 	for (const method of methodsExpected) {
-		t.is(typeof target[method], 'function');
+		expect(typeof target[method]).toBe('function');
 	}
 
-	t.is(target.listenerCount(), 0);
+	expect(target.listenerCount()).toBe(0);
 });
 
-test('bindMethods() - methodNames must only include Emittery methods', t => {
+test('bindMethods() - methodNames must only include Emittery methods', () => {
 	const emitter = new Emittery();
 	const target = {};
-	t.throws(() => emitter.bindMethods(target, ['noexistent']));
+	expect(() => emitter.bindMethods(target, ['noexistent'])).toThrow();
 });
 
-test('bindMethods() - must not set already existing fields', t => {
+test('bindMethods() - must not set already existing fields', () => {
 	const emitter = new Emittery();
 	const target = {
 		on: true
 	};
-	t.throws(() => emitter.bindMethods(target, ['on']));
+	expect(() => emitter.bindMethods(target, ['on'])).toThrow();
 });
 
-test('bindMethods() - target must be an object', t => {
+test('bindMethods() - target must be an object', () => {
 	const emitter = new Emittery();
-	t.throws(() => emitter.bindMethods('string', []));
-	t.throws(() => emitter.bindMethods(null, []));
-	t.throws(() => emitter.bindMethods(undefined, []));
+	expect(() => emitter.bindMethods('string', [])).toThrow();
+	expect(() => emitter.bindMethods(null, [])).toThrow();
+	expect(() => emitter.bindMethods(undefined, [])).toThrow();
 });
 
-test('mixin()', t => {
+test('mixin()', () => {
 	class TestClass {
 		constructor(v) {
 			this.v = v;
@@ -1107,64 +1057,57 @@
 	const TestClassWithMixin = Emittery.mixin('emitter', ['on', 'off', 'once', 'emit', 'emitSerial', 'onAny', 'offAny', 'clearListeners', 'listenerCount', 'bindMethods'])(TestClass);
 	const symbol = Symbol('test symbol');
 	const instance = new TestClassWithMixin(symbol);
-	t.true(instance.emitter instanceof Emittery);
-	t.true(instance instanceof TestClass);
-	t.is(instance.emitter, instance.emitter);
-	t.is(instance.v, symbol);
-	t.is(instance.listenerCount(), 0);
+	expect(instance.emitter instanceof Emittery).toBe(true);
+	expect(instance instanceof TestClass).toBe(true);
+	expect(instance.emitter).toBe(instance.emitter);
+	expect(instance.v).toBe(symbol);
+	expect(instance.listenerCount()).toBe(0);
 });
 
-test('mixin() - methodNames must be array of strings or undefined', t => {
+test('mixin() - methodNames must be array of strings or undefined', () => {
 	class TestClass {}
 
-	t.throws(() => Emittery.mixin('emitter', null)(TestClass));
-	t.throws(() => Emittery.mixin('emitter', 'string')(TestClass));
-	t.throws(() => Emittery.mixin('emitter', {})(TestClass));
-	t.throws(() => Emittery.mixin('emitter', [null])(TestClass));
-	t.throws(() => Emittery.mixin('emitter', [1])(TestClass));
-	t.throws(() => Emittery.mixin('emitter', [{}])(TestClass));
+	expect(() => Emittery.mixin('emitter', null)(TestClass)).toThrow();
+	expect(() => Emittery.mixin('emitter', 'string')(TestClass)).toThrow();
+	expect(() => Emittery.mixin('emitter', {})(TestClass)).toThrow();
+	expect(() => Emittery.mixin('emitter', [null])(TestClass)).toThrow();
+	expect(() => Emittery.mixin('emitter', [1])(TestClass)).toThrow();
+	expect(() => Emittery.mixin('emitter', [{}])(TestClass)).toThrow();
 });
 
-test('mixin() - must mixin all methods if no array supplied', t => {
+test('mixin() - must mixin all methods if no array supplied', () => {
 	const methodsExpected = ['on', 'off', 'once', 'events', 'emit', 'emitSerial', 'onAny', 'anyEvent', 'offAny', 'clearListeners', 'listenerCount', 'bindMethods', 'logIfDebugEnabled'];
 
 	class TestClass {}
 
 	const TestClassWithMixin = Emittery.mixin('emitter')(TestClass);
 
-	t.deepEqual(Object.getOwnPropertyNames(TestClassWithMixin.prototype).sort(), [...methodsExpected, 'constructor', 'emitter'].sort());
+	expect(Object.getOwnPropertyNames(TestClassWithMixin.prototype).sort()).toEqual([...methodsExpected, 'constructor', 'emitter'].sort());
 });
 
-test('mixin() - methodNames must only include Emittery methods', t => {
+test('mixin() - methodNames must only include Emittery methods', () => {
 	class TestClass {}
 
-	t.throws(() => Emittery.mixin('emitter', ['nonexistent'])(TestClass));
+	expect(() => Emittery.mixin('emitter', ['nonexistent'])(TestClass)).toThrow();
 });
 
-test('mixin() - must not set already existing methods', t => {
+test('mixin() - must not set already existing methods', () => {
 	class TestClass {
 		on() {
 			return true;
 		}
 	}
-	t.throws(() => Emittery.mixin('emitter', ['on'])(TestClass));
-});
-
-test('mixin() - target must be function', t => {
-	t.throws(() => Emittery.mixin('emitter')('string'));
-	t.throws(() => Emittery.mixin('emitter')(null));
-	t.throws(() => Emittery.mixin('emitter')(undefined));
-	t.throws(() => Emittery.mixin('emitter')({}));
+	expect(() => Emittery.mixin('emitter', ['on'])(TestClass)).toThrow();
 });
 
-test('isDebug default logger handles symbol event names and object for event data', async t => {
-	const emitter = new Emittery({debug: {name: 'testEmitter', enabled: true}});
-	const eventName = Symbol('test');
-	emitter.on(eventName, () => {});
-	await t.notThrowsAsync(emitter.emit(eventName, {complex: ['data', 'structure', 1]}));
+test('mixin() - target must be function', () => {
+	expect(() => Emittery.mixin('emitter')('string')).toThrow();
+	expect(() => Emittery.mixin('emitter')(null)).toThrow();
+	expect(() => Emittery.mixin('emitter')(undefined)).toThrow();
+	expect(() => Emittery.mixin('emitter')({})).toThrow();
 });
 
-test('isDebug can be turned on globally during runtime', t => {
+test('isDebug can be turned on globally during runtime', () => {
 	Emittery.isDebugEnabled = true;
 	const eventStore = [];
 
@@ -1181,14 +1124,14 @@
 	emitter.on('test', () => {});
 	emitter.emit('test', 'test data');
 	Emittery.isDebugEnabled = false;
-	t.true(eventStore.length > 0);
-	t.is(eventStore[2].type, 'emit');
-	t.is(eventStore[2].eventName, 'test');
-	t.is(eventStore[2].debugName, 'testEmitter');
-	t.is(eventStore[2].eventData, 'test data');
+	expect(eventStore.length > 0).toBe(true);
+	expect(eventStore[2].type).toBe('emit');
+	expect(eventStore[2].eventName).toBe('test');
+	expect(eventStore[2].debugName).toBe('testEmitter');
+	expect(eventStore[2].eventData).toBe('test data');
 });
 
-test('isDebug can be turned on for and instance without using the constructor', t => {
+test('isDebug can be turned on for and instance without using the constructor', () => {
 	const eventStore = [];
 
 	const emitter = new Emittery({
@@ -1204,9 +1147,9 @@
 
 	emitter.on('test', () => {});
 	emitter.emit('test', 'test data');
-	t.true(eventStore.length > 0);
-	t.is(eventStore[2].type, 'emit');
-	t.is(eventStore[2].eventName, 'test');
-	t.is(eventStore[2].debugName, 'testEmitter');
-	t.is(eventStore[2].eventData, 'test data');
+	expect(eventStore.length > 0).toBe(true);
+	expect(eventStore[2].type).toBe('emit');
+	expect(eventStore[2].eventName).toBe('test');
+	expect(eventStore[2].debugName).toBe('testEmitter');
+	expect(eventStore[2].eventData).toBe('test data');
 });
